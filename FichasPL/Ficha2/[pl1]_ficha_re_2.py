# -*- coding: utf-8 -*-
"""[PL1] Ficha RE 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BdT0OlXVuz9t_ATmike-X-YoZ9MYI9B9

# Ficha de Expressões Regulares 2

### Conceitos mais avançados de expressões regulares

- `.` - corresponde a uma ocorrência de qualquer caracter (exceto '\n', geralmente).
- `\w` - corresponde a um caracter alfanumérico (a-z, A-Z, 0-9 ou _).
- `\W` - corresponde a um caracter **não** alfanumérico.
- `\s` - corresponde a um caracter de *whitespace* (' ', '\t', ou '\n', por exemplo).
- `\S` - corresponde a um caracter que não seja *whitespace*.
- `\d` - corresponde a um dígito.
- `\D` - corresponde a um caracter que não seja um dígito.
- `\btot\w+` - corresponde a uma palavra **começada** por "tot" (o token `\b` representa uma *word boundary*, ou seja, o limite entre um caracter alfanumérico e outro não alfanumérico). Por outras palavras, captura a palavra "totalidade" mas não a palavra "batota". O token `\b` também pode ser usado no fim de palavras.
- `a(?=b)` - corresponde a um caracter `a` que tenha à sua frente um caracter `b`, mas não captura o caracter `b`. (*positive lookahead*)
- `a(?!b)` - corresponde a um caracter `a` que **não** tenha à sua frente um caracter `b`, mas não captura o caracter seguinte. (*negative lookahead*)
- `a(?<=b)` - corresponde a um caracter `a` que tenha atrás de si um caracter `b`, mas não captura o caracter `b`. (*positive lookbehind*)
- `a(?<!b)` - corresponde a um caracter `a` que **não** tenha atrás de si um caracter `b`, mas não captura o caracter anterior. (*negative lookbehind*)

Podemos usar *grupos de captura* em expressões regulares para isolar segmentos da string capturada. Usamos parênteses para definir grupos de captura.
"""

import re
m = re.search(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])', "13:49")

print(m)
print(m.groups()) # conjunto dos grupos de captura
print(m.group(0)) # toda a string capturada
print(m.group(1)) # o primeiro grupo de captura

"""O módulo re possui ainda *flags* que podemos usar nas suas funções. As mais úteis são:

- `re.I` ou `re.IGNORECASE`: faz uma correspondência *case insensitive*.
- `re.M` ou `re.MULTILINE`: os tokens de âncora `^` e `$` passam a corresponder ao início/fim de cada linha, em vez do início/fim de uma string.
- `re.S` ou `re.DOTALL`: o token `.` passa a corresponder também a um caracter `\n`.

Podemos usar estas flags da seguinte forma: `re.search(r'trans.*mar', "TRANSF\nORMAR", re.I | re.S)`

## Exercício 1 - Conversão de datas

Define a função `iso_8601` que converte as datas presentes numa string no formato DD/MM/AAAA para o formato ISO 8601 - AAAA-MM-DD, usando expressões regulares e grupos de captura.
"""

texto = """A 03/01/2022, Pedro viajou para a praia com a sua família.
Eles ficaram hospedados num hotel e aproveitaram o sol e o mar durante toda a semana.
Mais tarde, no dia 12/01/2022, Pedro voltou para casa e começou a trabalhar num novo projeto.
Ele passou muitas horas no escritório, mas finalmente terminou o projeto a 15/01/2022."""

def iso_8601(texto):
  return re.sub(r"(\d{2})/(\d{2})/(\d{4})", r"\3-\2-\1", texto)

print(iso_8601(texto))

"""## Exercício 2 - Validação de ficheiros

Escreve um programa que lê uma lista de nomes de ficheiros e determina se cada nome é válido ou não. O nome de um ficheiro deve conter apenas caracteres alfanuméricos, hífens, underscores ou pontos, seguido de uma extensão (e.g., ".txt", ".png", etc.).
"""

import re

file_names = [
  "document.txt", # válido
  "file name.docx", # inválido
  "image_001.jpg", # válido
  "script.sh.txt", # válido
  "test_file.txt", # válido
  "file_name.", # inválido
  "my_resume.docx", # válido
  ".hidden-file.txt", # válido
  "important-file.text file", # inválido
  "file%name.jpg" # inválido
]

def f(file_names):
    return [True if re.match(r"[\w\-\.]+(\.\w+)$", name) else False for name in file_names]

f(file_names)



"""### Alínea 2.1

Modifica o programa anterior para colocar os nomes de ficheiro válidos num dicionário, no qual as chaves deverão ser as extensões dos mesmos. Por outras palavras, agrupa os ficheiros por extensão.
"""

def f1(file_names):
  d = {}
  for name in file_names:
    m = re.match("[\w\-\.]+(?P<extension>\.\w+)$", name) 
    if m:
      key = m.group(1)
      
      if key in d:
        d[key].append(m.group())
      else:
        d[key] = [m.group()]
  return d
print(f1(file_names))

"""## Exercício 3 - Conversão de nomes

Escreve um filtro de texto que converte cada nome completo de uma pessoa encontrada num texto fonte, no formato `PrimeiroNome SegundoNome [...] UltimoNome` para o formato `UltimoNome, PrimeiroNome`. Por exemplo, "Rui Vieira de Castro" passa a "Castro, Rui". Atenção aos conectores "de", "dos", etc.
"""

texto = """Este texto foi feito por Sofia Guilherme Rodrigues dos Santos, com 
base no texto original de Pedro Rafael Paiva Moura, com a ajuda
dos professores Pedro Rangel Henriques e José João Antunes Guimarães Dias De Almeida.
Apesar de partilharem o mesmo apelido, a Sofia não é da mesma família do famoso
autor José Rodrigues dos Santos."""

def ex3(texto):
  return re.sub(r"([A-Z]\w+)(\s([A-Z]\w+|d[oa]s?))*\s([A-Z]\w+)", r"\4, \1", texto)

print(ex3(texto))

"""## Exercício 4 - Códigos postais 2

Define uma função `codigos_postais` que recebe uma lista de códigos postais e divide-os com base no hífen. Ao contrário do exercício da ficha anterior, esta função pode receber códigos postais inválidos. A função deve devolver uma lista de pares e apenas processar cada linha uma vez.
"""

lista = [
    "4700-000", # válido
    "9876543", # inválido
    "1234-567", # válido
    "8x41-5a3", # inválido
    "84234-12", # inválido
    "4583--321", # inválido
    "9481-025" # válido
]

def ex4(lista):
  r = []
  for l in lista:
    m = re.match("(\d{4})-(\d{3})", l)
    if m:
      r.append((m.group(1), m.group(2)))
  return r
  
print(ex4(lista))

"""## Exercício 5 - Expansão de abreviaturas

Escreve um filtro de texto que expanda as abreviaturas que encontrar no texto fonte no formato "/abrev".
"""

abreviaturas = {
    "UM": "Universidade do Minho",
    "LEI": "Licenciatura em Engenharia Informática",
    "UC": "Unidade Curricular",
    "PL": "Processamento de Linguagens"
}

texto = "A /abrev{UC} de /abrev{PL} é muito fixe! É uma /abrev{UC} que acrescenta muito ao curso de /abrev{LEI} da /abrev{UM}."

def ex5(texto):
  return re.sub(r"/abrev{(\w+)}", lambda x: abreviaturas.get(x.group(1)), texto)

print(ex5(texto))

"""## Exercício 6 - Matrículas

Define uma função `matricula_valida` que recebe uma string de texto e determina se esta contém uma matrícula válida. Uma matrícula segue o formato AA-BB-CC, no qual dois dos três conjuntos devem ser compostos por números e o terceiro por letras maiúsculas (por exemplo, 01-AB-23), ou o novo formato no qual dois dos conjuntos são compostos por letras maiúsculas e o terceiro por números (por exemplo, 89-WX-YZ). Os conjuntos podem ser separados por um hífen ou um espaço.

Extra: Garante que o mesmo separador é usado para separar os três conjuntos.
"""

matriculas = [
    "AA-AA-AA", # inválida
    "LR-RB-32", # válida
    "1234LX", # inválida
    "PL 22 23", # válida
    "ZZ-99-ZZ", # válida
    "54-tb-34", # inválida
    "12 34 56", # inválida
    "42-HA BQ" # válida, mas inválida com o requisito extra
]

def ex6(lista):
  pass
  
print(ex6(matriculas))

"""## Exercício 7 - *Mad Libs*

O jogo *Mad Libs*, bastante comum em países como os Estados Unidos, consiste em pegar num texto com espaços para algumas palavras e preencher esses espaços de acordo com o tipo de palavra que é pedida.

Escreve um programa que lê um texto no formato *Mad Libs* e pede ao utilizador para fornecer palavras que completem corretamente o texto.
"""

texto = """Num lindo dia de [ESTAÇÃO DO ANO], [NOME DE PESSOA] foi passear com o seu [EXPRESSÃO DE PARENTESCO MASCULINA]. 
Quando chegaram à [NOME DE LOCAL FEMININO], encontraram um [OBJETO MASCULINO] muito [ADJETIVO MASCULINO].
Ficaram muito confusos, pois não conseguiam identificar a função daquilo.
Seria para [VERBO INFINITIVO]? Tentaram perguntar a [NOME DE PESSOA FAMOSA], que também não sabia.
Desanimados, pegaram no objeto e deixaram-no no [NOME DE LOCAL MASCULINO] mais próximo. 
Talvez os [NOME PLURAL MASCULINO] de lá conseguissem encontrar alguma utilidade para aquilo."""

# ...

"""## Exercício 8 - Remoção de repetidos

Escreve um filtro de texto que sempre que encontrar no texto fonte uma palavra repetida elimina as repetições, ou seja, substitui a lista de palavras por 1 só palavra.
"""

# ...